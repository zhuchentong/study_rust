fn main() {
    let r;

    {
        // 数据的存活的时间应该可以覆盖引用存活的时间
        let x = 5;
        r = x.clone();
    }

    println!("r: {}", r);

    // r - a' >  2--10
    // x - b' >  4--8
    // 被引用对象存活时间应该不少于引用对象存活时间
}

// 当传入参数声明周期不同是，返回参数应该与生成周期更短的一致
// 输入生命周期
// 输出生命周期
fn largest<'a>(a: &'a str, b: &'a str) -> &'a str {
    if a.len() > b.len() {
        a
    } else {
        b
    }
}

// 1. 编译器会为每一个引用增加不同一个生命周期参数
// 2. 如果只有一个声明周期参数，该生命周期参数会被赋予所有输出生命周期参数
// 3. 如果有多个生命周期参数，但其中一个是 &self 或 &mut self，那么 self 的生命周期会被赋予所有输出生命周期参数

// 静态生命周期 'static
// 引用可以在整个程序的持续时间内存活

struct Foo<'a> {
    bar: &'a i32,
}

fn baz(f: Foo) -> &i32 {
    f.bar
}

fn bzc<'a>(f: &Foo<'a>) -> &'a i32 {
    f.bar
}
